# Архитектура проекта "Arkanoid" (Survival Platformer)

## Обзор
Проект представляет собой 2D Action-Platformer с элементами выживания (смена дня и ночи, волны врагов).

**Технологический стек:**
*   **Движок:** Godot 4.5+ (GL Compatibility).
*   **Язык:** GDScript (статическая типизация применяется частично).
*   **Физика:** CharacterBody2D для сущностей, Area2D для триггеров и боевой системы.

### ⚠️ Примечание о Legacy Reference
В папке `_reference_code/` находится прототип на Python (Pygame). **Этот код имеет низкое качество реализации и архитектуры.** Он оставлен в проекте **исключительно как список механик** (например, поведение босса, типы оружия), которые планируется реализовать в Godot-версии.
**Запрещено** копировать архитектурные решения из референса. Реализация в Godot должна следовать паттернам, описанным ниже.

---

## Стандарты именования и Кодстайл (Naming Conventions)

Проект следует официальному **Godot Style Guide**.

1.  **Файловая структура (File System):**
    *   Все папки и файлы должны быть в `snake_case` (строчные буквы, разделение нижним подчеркиванием).
    *   *Пример:* `res://entities/player/player.tscn`, `res://components/damage_box/damage_box.gd`.
    *   *Исключение:* C# скрипты (если появятся) именуются в PascalCase.

2.  **Сцена и Узлы (Scene Tree):**
    *   Имена узлов в дереве сцены — `PascalCase`.
    *   *Пример:* `Player`, `DamageBox`, `LevelManager`.

3.  **Скрипты (GDScript):**
    *   Классы (внутри кода) и Типы: `PascalCase`.
    *   Переменные и функции: `snake_case`.
    *   Константы и Enums: `SCREAMING_SNAKE_CASE` (константы), `PascalCase` (имена Enum).

---

## Ключевые паттерны и принципы

### 1. Компонентная система (Composition)
Проект активно использует вложенность сцен для создания сложного поведения:
*   **DamageBox:** Отдельная сцена (`damage_box.tscn`), инкапсулирующая логику нанесения (`HitBox`) и получения (`HurtBox`) урона. Подключается к Игроку и Врагам.
*   **Lantern:** Компонент освещения, прикрепляемый к сущностям.

### 2. Конечные автоматы (FSM)
Управление состоянием сущностей реализовано через паттерн Finite State Machine.
*   **Игрок (`player.gd`):** Использует `enum` (`MOVE`, `ATTACK`, `BLOCK`, `DEATH` и др.) и блок `match` в `_physics_process` для переключения логики.
*   **Враги (`mushroom.gd`):** Аналогичный подход с состояниями (`IDLE`, `CHASE`, `ATTACK`).

### 3. Шина событий (Event Bus)
Взаимодействие между независимыми системами осуществляется через глобальный синглтон `Signals` (`signals.gd`).
*   **Примеры сигналов:** `player_position_update`, `enemy_attack`, `day_time`, `enemy_died`.
*   Это позволяет развязать спавнеры, UI и игровые сущности друг от друга.

### 4. Внедрение зависимостей (Dependency Injection)
Контроллеры верхнего уровня (`game.gd`, `spawner.gd`) используют аннотацию `@export` для получения ссылок на необходимые узлы (свет, UI, сцены мобов). Это позволяет настраивать связи в редакторе без жесткого кодирования путей (`GetNode`).

### 5. Управление ресурсами и путями (Resource Management)

Проект следует принципу **"Soft References"** (Мягкие ссылки) для обеспечения гибкости файловой структуры.

1.  **Запрет на Hardcoded Paths:**
    *   В коде (GDScript) запрещено использовать строковые пути к ресурсам (например, `load("res://entities/enemies/mushroom.tscn")`), за исключением специальных классов-менеджеров (`SceneManager`).
    *   Вместо этого ресурсы должны назначаться через переменные с аннотацией `@export` в редакторе. Это позволяет Godot автоматически отслеживать перемещение файлов и обновлять ссылки (благодаря системе UID).

2.  **Централизация путей:**
    *   Единственное место, где допускаются строковые константы путей к сценам — синглтон `SceneManager`. При рефакторинге файловой структуры необходимо вручную обновлять пути только в этом файле.

3.  **Локальные зависимости:**
    *   Допускается использование `$` (GetNode) только для дочерних элементов внутри **той же самой сцены** (Composition). Скрипт не должен пытаться получить доступ к родителям (`..`) или соседним узлам в дереве сцены через жесткие пути.

---

## 6. Стратегия взаимодействия с LLM (AI Collaboration Strategy)

Этот раздел является **обязательным регламентом** для AI-агентов, работающих с проектом.

### Правила генерации кода

1.  **Полный вывод файлов (Full File Output):**
    *   При обновлении или создании файла AI обязан выводить код **целиком**.
    *   **Запрещено** использовать сокращения вида `// ... existing code ...`, `// ... rest of the file`, `# код остался прежним`.
    *   Это необходимо для корректного применения изменений через автоматизированные инструменты или copy-paste без риска потери контекста.

2.  **Инструкции по настройке Инспектора (Inspector Setup Instructions):**
    *   Так как проект использует Dependency Injection через `@export`, код часто не будет работать "из коробки" без настройки в редакторе Godot.
    *   После каждого блока кода, содержащего новые `@export` переменные, AI обязан предоставить маркированный список действий (**Checklist**) для пользователя.
    *   **Формат инструкций:**
        ```text
        **Настройка в Инспекторе (Inspector Setup):**
        1. Выберите узел [ИмяУзла].
        2. В группе [НазваниеГруппы] назначьте параметр [ИмяПеременной]:
           - Перетащите [Файл.tscn] из FileSystem.
           - ИЛИ Нажмите "Assign" и выберите узел [NodePath] в дереве сцены.
        ```

3.  **Лаконичность и Чистота:**
    *   Если сложное решение имеет полноценные простые альтернативы, их следует предпочесть.
    *   Не оставлять закомментированный старый код (dead code). Удалять его сразу.

4.  **Рефлексия документации:**
    *   При изменении архитектуры AI должен предложить обновление `ARCHITECTURE.md` и `TECH_DEBT.md`.

---

## Основные подсистемы

### Глобальные Синглтоны (Autoloads)
1.  **Global:** Хранит общее состояние игры (количество золота, позиция игрока).
2.  **Signals:** Центральный хаб для обмена сообщениями.
3.  **SceneManager:** Управляет безопасной сменой сцен и загрузкой (Menu <-> Game).

### Игрок (`entities/player/`)
*   **Логика:** Обработка ввода, перемещение, атака (комбо-система через `AnimationPlayer`), блок.
*   **Характеристики:** Узел `stats` (`Stats.tscn`) управляет здоровьем, стаминой и их регенерацией.
    *   *Особенность:* `stats` также отвечает за UI-бары здоровья и стамины.

### Враги (`entities/enemies/`)
*   **Mushroom:** Реализует полноценный цикл преследования и атаки. Использует навигацию к вектору позиции игрока.
*   **Robot:** Упрощенная логика, использующая группы (`is_in_group("player")`) для обнаружения цели.

### Игровой мир и Цикл (`scenes/game.gd`)
*   **Day/Night Cycle:** Система состояний (`MORNING`, `DAY`, `EVENING`, `NIGHT`). Управляет глобальным освещением (`DirectionalLight2D`) и локальными источниками через `Tween`.
*   **Spawners:** Объекты, которые подписываются на сигналы смены времени суток и генерируют волны врагов.

### Боевая система
*   Основана на взаимодействии слоев физики (Physics Layers).
*   **Layer 5:** PlayerHurtBox.
*   **Layer 6:** EnemyHurtBox.
*   Урон передается через сигналы `area_entered` в компонентах `DamageBox`.

### Система сохранений (`systems/save_system/manager.gd`)
*   Использует `FileAccess` для записи данных (золото, позиция игрока) в `user://savegame.save`.
*   Динамически находит игрока в группе `player` для сохранения его координат.